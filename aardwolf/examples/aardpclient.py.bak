import sys
import asyncio
import traceback
import multiprocessing as mp

from aardwolf.commons.url import RDPConnectionURL
from aardwolf.commons.queuedata import RDPDATATYPE
from aardwolf.commons.queuedata.keyboard import RDP_KEYBOARD_SCANCODE
from aardwolf.commons.queuedata.mouse import RDP_MOUSE
from aardwolf.utils.qt import RDPBitmapToQtImage
from aardwolf.utils.apq import AsyncProcessQueue

from PyQt5.QtWidgets import QApplication, QMainWindow, qApp, QLabel
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot, QThread, Qt
from PyQt5.QtGui import QPainter, QImage, QPixmap



#https://gist.github.com/jazzycamel/8abd37bf2d60cce6e01d

class RDPClientConsoleSettings:
	def __init__(self, rdp_in:AsyncProcessQueue, rdp_out:AsyncProcessQueue, gui_start_evt:mp.Event, gui_stop_evt:mp.Event, url:str):
		self.rdp_in:AsyncProcessQueue = rdp_in
		self.rdp_out:AsyncProcessQueue = rdp_out
		self.gui_start_evt:mp.Event = gui_start_evt
		self.gui_stop_evt:mp.Event = gui_stop_evt
		self.height:int = 1024
		self.width:int = 768
		self.mhover:int = True
		self.keyboard:int = True
		self.bpp:int = 16
		self.url:str = url

class RDPImage:
	def __init__(self,x,y,image,width,height):
		self.x = x
		self.y = y
		self.image = image
		self.width = width
		self.height = height

class RDPInterfaceThread(QObject):
	result=pyqtSignal(RDPImage)
	
	def __init__(self, parent=None, **kwargs):
		super().__init__(parent, **kwargs)
		self.rdp_in = None
		self.rdp_out = None
	
	def add_queues(self, rdp_in, rdp_out):
		self.rdp_in = rdp_in
		self.rdp_out = rdp_out

	@pyqtSlot()
	def start(self):
		while True:
			data = self.rdp_in.get()
			if data is None:
				return
			if data.type == RDPDATATYPE.VIDEO:
				image = RDPBitmapToQtImage(data.width, data.height, data.bitsPerPixel, data.is_compressed, data.data)
				ri = RDPImage(data.x, data.y, image, data.height, data.width)
				self.result.emit(ri)
			else:
				print('Unknown incoming data: %s'% data)


class RDPClientQTGUI(QMainWindow):
	def __init__(self, settings:RDPClientConsoleSettings):
		super().__init__()
		self.settings = settings
		self.rdp_in = settings.rdp_in
		self.rdp_out = settings.rdp_out
		self.gui_stop_evt = settings.gui_stop_evt

		# enabling this will singificantly increase the bandwith
		self.mhover = settings.mhover
		# enabling keyboard tracking
		self.keyboard = settings.keyboard

		# setting up the main window with the requested resolution
		self.setGeometry(0,0, self.settings.width, self.settings.height)
		# this buffer will hold the current frame and will be contantly updated
		# as new rectangle info comes in from the server
		self._buffer = QImage(self.settings.width, self.settings.height, QImage.Format_RGB32)
		
		
		# setting up worker thread in a qthread
		# the worker recieves the video updates from the connection object
		# and then dispatches it to updateImage
		# this is needed as the RDPConnection class uses async queues
		# and QT is not async so an interface between the two worlds
		# had to be created
		self._thread=QThread()
		self._threaded=RDPInterfaceThread(result=self.updateImage)
		self._threaded.add_queues(self.rdp_in, self.rdp_out)
		self._thread.started.connect(self._threaded.start)
		self._threaded.moveToThread(self._thread)
		qApp.aboutToQuit.connect(self._thread.quit)
		self._thread.start()

		# setting up the canvas (qlabel) which will display the image data
		self._label_imageDisplay = QLabel()
		self.setCentralWidget(self._label_imageDisplay)
		
		# enabling mouse tracking
		self.setMouseTracking(True)
		self._label_imageDisplay.setMouseTracking(True)
	
	def closeEvent(self, event):
		self.rdp_in.put(None)
		self._thread.quit()
		event.accept()
	
	def updateImage(self, event):
		with QPainter(self._buffer) as qp:
			qp.drawImage(event.x, event.y, event.image, 0, 0, event.width, event.height)
		pixmap01 = QPixmap.fromImage(self._buffer)
		pixmap_image = QPixmap(pixmap01)
		self._label_imageDisplay.setPixmap(pixmap_image)
		self._label_imageDisplay.setAlignment(Qt.AlignCenter)
		self._label_imageDisplay.setScaledContents(True)
		self._label_imageDisplay.setMinimumSize(1,1)
		self._label_imageDisplay.show()
	
	def keyPressEvent(self, e):
		if self.keyboard is False:
			return
		ki = RDP_KEYBOARD_SCANCODE()
		ki.keyCode = e.nativeScanCode()
		ki.is_pressed = True
		if sys.platform == "linux":
			#why tho?
			ki.keyCode -= 8
		self.rdp_out.put(ki)
	
	def keyReleaseEvent(self, e):
		if self.keyboard is False:
			return
		ki = RDP_KEYBOARD_SCANCODE()
		ki.keyCode = e.nativeScanCode()
		ki.is_pressed = False
		if sys.platform == "linux":
			ki.keyCode -= 8
		self.rdp_out.put(ki)
	
	def mouseMoveEvent(self, e):
		if self.mhover is False:
			return
		mi = RDP_MOUSE()
		mi.xPos = e.pos().x()
		mi.yPos = e.pos().y()
		mi.button = 0
		mi.pressed = False
		self.rdp_out.put(mi)

	def mouseReleaseEvent(self, e):
		"""
		mouse button release event
		"""
		button = e.button()
		buttonNumber = 0
		if button == Qt.LeftButton:
			buttonNumber = 1
		elif button == Qt.RightButton:
			buttonNumber = 2
		elif button == Qt.MidButton:
			buttonNumber = 3

		mi = RDP_MOUSE()
		mi.xPos = e.pos().x()
		mi.yPos = e.pos().y()
		mi.button = buttonNumber
		mi.pressed = False

		self.rdp_out.put(mi)


	def mousePressEvent(self, e):
		button = e.button()
		buttonNumber = 0
		if button == Qt.LeftButton:
			buttonNumber = 1
		elif button == Qt.RightButton:
			buttonNumber = 2
		elif button == Qt.MidButton:
			buttonNumber = 3

		mi = RDP_MOUSE()
		mi.xPos = e.pos().x()
		mi.yPos = e.pos().y()
		mi.button = buttonNumber
		mi.pressed = True

		self.rdp_out.put(mi)
	

class ClientUI(mp.Process):
	def __init__(self, settings:RDPClientConsoleSettings):
		mp.Process.__init__(self)
		self.settings:RDPClientConsoleSettings = settings
	
	def run(self):
		self.settings.gui_start_evt.wait() # waiting for connection
		if self.settings.gui_stop_evt.is_set() is True:
			#connection failed, returning
			return
		app = QApplication(sys.argv)
		demo = RDPClientQTGUI(self.settings)
		demo.show()
		app.exec_()
		self.settings.gui_stop_evt.set()
		qApp.quit()


async def amain(settings:RDPClientConsoleSettings):
	async def monitor_out(qt_out_q, rdp_in_q, gui_stop_evt):
		try:
			while not gui_stop_evt.is_set():
				data = await qt_out_q.coro_get()
				await rdp_in_q.put(data)
		except Exception as e:
			traceback.print_exc()
	
	async def queue_converter(rdp_in, ext_out_queue, gui_stop_evt):
		while not gui_stop_evt.is_set():
			res = await ext_out_queue.get()
			await rdp_in.coro_put(res)

	try:
		#url = 'rdp+ntlm-password://TEST\\Administrator:Passw0rd!1@10.10.10.103'
		#url = 'rdp+kerberos-password://TEST\\Administrator:Passw0rd!1@win2016ad.test.corp/?dc=10.10.10.2'
		#url = 'rdp+ntlm-nt://TEST\\Administrator:f8963568a1ec62a3161d9d6449baba93@10.10.10.103'
		rdpurl = RDPConnectionURL(settings.url)
		conn = rdpurl.get_connection()
		conn.video_bpp_max = settings.bpp
		conn.video_bpp_min = settings.bpp
		conn.video_height = settings.height
		conn.video_width = settings.width
		connection_stop_evt = asyncio.Event()
			
		_, err = await conn.connect()
		if err is not None:
			raise err
		settings.gui_start_evt.set()
		monitor_out_task = asyncio.create_task(monitor_out(settings.rdp_out, conn.ext_in_queue, settings.gui_stop_evt))
		queue_task = asyncio.create_task(queue_converter(settings.rdp_in, conn.ext_out_queue, settings.gui_stop_evt))
		while not settings.gui_stop_evt.is_set():
			await asyncio.sleep(0.2)
		connection_stop_evt.set()
		queue_task.cancel()
		monitor_out_task.cancel()
		try:
			await asyncio.wait_for(conn.terminate(),1)
		except:
			pass
		settings.gui_stop_evt.set()
		settings.gui_start_evt.set()
		return
			
	except Exception as e:
		settings.gui_stop_evt.set()
		settings.gui_start_evt.set()
		traceback.print_exc()

def main():
	import argparse
	parser = argparse.ArgumentParser(description='Async RDP Client')
	parser.add_argument('-v', '--verbose', action='count', default=0, help='Verbosity, can be stacked')
	parser.add_argument('--no-mouse-hover', action='store_false', help='Disables sending mouse hovering data. (saves bandwith)')
	parser.add_argument('--no-keyboard', action='store_false', help='Disables keyboard input. (whatever)')
	parser.add_argument('--res', default = '1024x768', help='Resolution in "WIDTHxHEIGHT" format. Default: "1024x768"')
	parser.add_argument('--bpp', choices = [4, 8, 15, 16, 24], default = 16, type=int, help='Bits per pixel.')
	parser.add_argument('url', help="RDP connection url")

	args = parser.parse_args()

	width, height = args.res.upper().split('X')
	height = int(height)
	width = int(width)

	
	rdp_in = AsyncProcessQueue()
	rdp_out = AsyncProcessQueue()
	gui_start_evt = mp.Event()
	gui_stop_evt = mp.Event()
	settings = RDPClientConsoleSettings(rdp_in, rdp_out, gui_start_evt, gui_stop_evt, args.url)
	settings.height = height
	settings.width = width
	settings.mhover = args.no_mouse_hover
	settings.keyboard = args.no_keyboard
	settings.bpp = args.bpp


	clientui = ClientUI(settings)
	clientui.start()

	loop = asyncio.get_event_loop()
	loop.run_until_complete(amain(settings))
	loop.close()
	rdp_in.join_thread()
	rdp_out.join_thread()


	clientui.join()
	print('???exit pls')
	sys.exit(0)
	print('why no exit????')
	
	

if __name__ == '__main__':
	main()